# 《量化交易之路 用python做股票量化分析》要点笔记

## 量化引言

### 什么是量化交易

普通的交易由交易者根据自身的经验或者偏好进行投资决策，量化交易通过将数据（行情历史、基本面信息及新闻资讯等）输入量化模型后，利用计算机及统计学技术方法分析数据，产生交易信号进行交易决策。

量化交易之以数学模型代替人为的主观判断，利用计算机技术从庞大的历史数据中海选出能带来超额收益的多种“大概率”事件以制定策略。

量化模型一般包括选股模块、择时模块、风险模块。

传统的投资决策不论是技术面分析还是基本面分析都属于定性分析。

定性分析通过人的思维来完成，优点是深度上占有绝对优势。

量化交易使用定量分析，它以历史数据分析为基础，利用数学、统计学等工具高效快速地进行决策。

定量分析利用计算机强大的运算能力，在广度上占有绝对优势。定量分析中使用到定性分析中很多技术，大多数情况是人的思维对定性分析的高度抽象形成模式，将模式运用到定量分析以提升广度，在**大数定理**的魔力下，与市场博弈

### 投资？投机？赌博？

赌博靠的是运气，完全无法得到概率优势。

投机需要技巧和经验，衡量得失，获取概率优势。

股票就是投资，期货就是投机。

量化交易中大多数策略是基于对历史规律的总结，在规律的基础上发现概率优势，它的最大理论依据是**人性的相似性以及人性很难改变的事实**。如果每一个瞬间的股票价格都是全体交易者对价值所达成的一种瞬间共识，那么历史的规律在今后的交易中同样具有指导意义。

传统意义上的投资目标需要一个相对较大的概率优势目标，也就是说，投资模板需要一个比较明确的预测结果。

投资是指前期投入大量资源对投资目标进行研究分析，以活动丰厚投资回报为目标，进行长期投资的行为才能称作投资，其他所有的简单分析、中短期持有行为都是投机范畴。

量化交易更倾向于投机范畴

?>量化分析主要从历史数据中判断短期价格走势概率，就如一个拳手出拳，量化模型通过此前的数据，发现拳手此时已经举拳了，那么量化模型会判断他出拳的概率会很大，这是一个短期判断，会比较准确，但是量化模型很难判断该拳手明天中午会不会吃饭，因为对于长期判断，量化模型已经丧失了数据，没有精确的数据来做概率判断，就没有让人信服的理由

### 量化交易的优势

优势：

+ 通过计算机运算能力，在市场广度分析上占有绝对优势
+ 通过历史规律的总结，在其基础上发现概率优势，形成良好投机基础

交易者常常有“交易瘾”，他们在做交易是会有快感，其交易的主要目的是寻找刺激，他们企图抓住市场中每一次价格波动，贪婪地不想放过任何一次机会。

心理学发现，交易瘾有交易决策所带来的快感造成，因此不再决策的最前沿就不会无法自拔，通过量化交易，交易者可以抽离决策前沿。

**简单即美，如在期货市场，作者最信奉的策略是3天内不能盈利边平仓**

### 避免逆势操作

股票的价值是相对的，极端来说可以认为完全没有价值，价格却是市场中买卖双方达成的共识，它是绝对的。

顺势交易是投资者必须遵循的交易模式，但大多数投资者喜欢逆势操作，比如只在股票下跌很多时买入，造成捡便宜的心理。投资者在股票下跌很多后买入股票，会有种错觉：反正很多人买的价格比我高，我不怕，要死大家一起死。相反，投资者在股票价格突破后不敢买入：我不能在最高点买入，买了后，股票价格下跌就只有我一个人死了。

均值回复模式：假设之前的股价上涨只是暂时的，价格会恢复到一个相对正常的水平，也就说随后的一段时间内股价会下跌，其理论依据为价格将围绕价值上下波动。

### 避免重仓交易

重仓交易的危害不止是让交易者产生重大亏损这么简单。

交易中经常会出现买入后初始阶段并没有盈利的情况，在仓位小的情况下加上合理的止损策略，完全可以等待走势步入正轨，但过大的仓位会导致资金的大波动，交易者因无法承受资金波动选择过早离场，因而间接步入短线的陷阱。

很多的重仓交易是交易者选择向下加仓的结果，集交易者不断加仓已经亏损很多的头寸，企图通过降低成本来实现交易反转，间接步入逆势的陷阱

?>头寸：款项的意思，指投资者拥有或借用的资金数量

交易中应追求**让利润尽情奔跑，让亏损尽快止损**，而不是追求胜率，胜率毫无意义

量化交易策略都会完成回测及回测结果度量，即通过回测及回测结果验证我们的交易策略的可行性，是具有概率上的优势的交易策略，它具有正期望的投资回报。

### 从历史中验证交易策略是否可行

开发交易策略都要验证策略是否可行，通过量化交易将需要验证的策略实现后进行历史回测，通过对回测结果进行度量即可大致清楚该测了是否有效以及有效范围

?>回测面临一个重要问题就是，我们开发的交易策略，在回测过程中，进行交易，这些交易如果是在真实世界中是会产生复杂反应的，而回测系统毕竟只是模拟过去的交易环境无法完全捕捉到所有的变化，所有回测和真实情况还是有差距的

?>交易市场是个二级混沌的，所谓二级混沌就是对交易市场本身的研究或交互都会影响到市场整体，比如你发表一篇读某个股票的看法，某人可能看了你这篇分析就买入了这只股票，此时市场就发生变化了，想天气就是一级混沌的，对天气的预测观察不会让天气发现太大的变化，所以我们对天气的预测会越来越准确，但预测市场就会更加困难

交易者实际上并不需要过多关注盘间的价格波动，这样才能客观地对交易进行控制，不会被过多无意义的干扰打乱节奏。

### 量化交易正确认识

实际上，真正的基本面分析的进入门槛很高的，需要大量的资源和调研资金，并不适合个人投资者。

基本面分析的结果为长期预测结构，集通过大量的资料进行基本面调研后，寻找在长期投资期间具有丰厚回报的目标。

基本面分析以统计学为基础，通过寻找概率优势进行分析，分析结果为概率。

技术分析在中短期投资区间内有效，很多量化交易策略是基于浅层基本面数据分析+技术分析实现的。

**一种分析方法知道的人多了，使用的人多了，自然也就失效了**

在投资领域中没有一种方式就可以永远盈利，唯一不变的是变化和手续费。量化分析在这方面反而有自己的优势，分析变化，调整策略，通过数据反向指导人的思维调整定性分析方法，再此抽象到定量分析。

### 量化交易没有神奇魔法

现在所有的人工智能都属于弱人工智能（现在：2018-5-13）

阿尔法围棋的本质是多个弱人工智能效力叠加，通过游戏规则取胜。

虽然市场无法预测，但市场并不是杂乱无章的，由于市场参与者的非理性行为（有效市场假说不成立），通过历史数据发现规律，一定可以获得一些概率上的优势，作者认为在预测和混沌间存在一个种状态，这种状态可以使用概率来描述。即通过算法来找到这些概率的分布，预测市场的混沌。

### 不要抱有不劳而获的幻想

量化交易的基础依旧是交易，交易付出的代价是相当高的：成功的交易者不但需要付出资金成本，忍受交易的各种精神折磨，反人性的训练自己的交易技术，而且主要是要独立思考，不断否定自自我，不断付出大量时间去学习更新自己，是刀尖上舔学的工作

有效市场假说认为市场价格波动是随机的，交易者不可能持续从市场中获利。但市场并不是完全有效的。

影响市场的原因无限多，且非线性关系，即无限解系统，所以无法通过复杂化系统来实现预测交易的效果，不论使用技术有多复杂高深，战胜市场的唯一方式依然是获得概率优势。

只有简单的策略才能在长期投资中保存高度的稳定概率优势。

### 认清市场，认清自己

自动化交易占据美国股票市场 60% 以上的成交量。在美国，很多高频交易为了通信速度能有几毫秒的提升，不惜在太平洋底部搭建自己的通信网络。

选定交易品种，股票、期权、期货、外汇、比特币等都要考量，针对你的资金量、硬件设备等作出取舍。比如期货交易由于市场本身的特性，很多交易策略都是针对盘口数据做出快速反应，这样，硬件设备确实是能否获利的关键，高平交易也不适合个人投资者。但很多交易策略对硬件设备和速度要求没有那么高。

大机构的大资金在市场中，每一次出手时需要考虑冲击成本，冲击成本是指在交易中需要迅速而且大规模地买进或卖出证券，未能按照预定价位成交，从而多支付的成本.

?>资金量太大，没有那么多可以买，所以交易品种价格上涨了

冲击成本被认为机构大户难以摆脱的致命伤等不利因素。

要认清自己的策略与资金量是否匹配，尽量不要使用杠杆，杠杆放大了风险与收益的同时，也放大了希望和恐惧，期货市场投资者平均存活周期为6个月。

个人投资者需要对市场有足够的认知、敬畏，认清自己的资金量是不是可以满足市场的最低入门门槛，并且杠杆越高的市场要求投资者具有越高的自律性，控制自己的贪婪，不和市场较劲。

### 量化交易的目的

自由

?> 只有抛弃一切，才能获得自由 《搏击俱乐部》

我们拥有的其实只有时间

## 量化语言 --- python

python语言里一些高级语法，如混入类mixmins、元编程metaclass和装饰器，他们都是一些最优解决方案中必不可少的技术，甚至描述器这个一般用不到的技术，在编写大型项目中，也使项目结构更加优雅。

### 1
isinstance() --> 验证某个对视是否是某个类型

### 2
python中字符串是不可变对象（immutable），一般对字符串操作的API都是返回一个新的字符串。

通过id()函数可以获得对象的内存地址，如果两个对象的内存地址是一样的，那么这两个对象就是一个对象。

### 3
列表list是一种**有序**容器，可以对元素进行增、删、改操作

集合set是一个**无序**容器，且集合中的元素没有重复

### 4
zip的效果是同时迭代多个序列，每次分别从一个序列中取一个元素，一旦其中某个序列到达结尾，则迭代结束

```python
In [51]: m = [i for i in range(10)]

In [52]: m1 = [x for x in range(5)]

In [53]: m
Out[53]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [54]: m1
Out[54]: [0, 1, 2, 3, 4]

In [55]: m2 = [(a,b) for a,b in zip(m,m1)]

In [56]: m2
Out[56]: [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]
```

### 5
可命名元祖：nametuple

```python
n [59]: from collections import namedtuple

In [60]: s = namedtuple('s',('a','b'))

In [61]: sl = [s(a,b) for a,b in zip(m,m1)]

In [62]: sl
Out[62]: [s(a=0, b=0), s(a=1, b=1), s(a=2, b=2), s(a=3, b=3), s(a=4, b=4)]

In [63]: sl[0].a
Out[63]: 0
```

### 6
字典推到式

```python
In [67]: sb = {a:b for a,b in zip(m,m1)}

In [68]: sb
Out[68]: {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}
```

dict使用key-value存储，可以通过key快速查询value，使用keys()和values()函数可以分别返回字典中的key列表与value列表

### 7

有序字典：OrderedDict

```python
In [71]: from collections import OrderedDict

In [72]: sb = OrderedDict((a,b) for a,b in zip(m,m1))

In [73]: sb
Out[73]: OrderedDict([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)])

In [74]: sb.keys()
Out[74]: odict_keys([0, 1, 2, 3, 4])
```

### 8

lambda函数轻量级完成了函数的任务，特别是针对reduce()和map()等高级函数

找字典中，第二个大的元素

```python
In [73]: sb
Out[73]: OrderedDict([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)])

In [75]: find_second_max_lambda = lambda sb:sorted(zip(sb.values(), sb.keys()))[-2]

In [76]: find_second_max_lambda(sb)
Out[76]: (3, 3)
```

python中函数可以返回多个返回值，但实际上仍然是一个返回值，只不过返回值通过打包成一个tuple元组返回，实现多个返回值

### 9

常见高级函数：

+ map()函数：接受两个参数，一个是函数，一个是序列，map()把传入的函数依次作用于序列的每个元素，并把结果作为新的序列返回
+ filter()函数：接受两个参数，一个是函数，一个是序列，filter()把传入的函数依次作用于每个序列中的每个元素上，根据返回值是True还说False决定保留还是丢弃元素，结果序列是所有返回值为True的子集
+ reduce()函数：


